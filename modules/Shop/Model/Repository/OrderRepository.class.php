<?php

namespace Cx\Modules\Shop\Model\Repository;

/**
 * OrderRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class OrderRepository extends \Doctrine\ORM\EntityRepository
{
    const STATUS_PENDING   = 0;
    const STATUS_CONFIRMED = 1;
    const STATUS_DELETED   = 2;
    const STATUS_CANCELLED = 3;
    const STATUS_COMPLETED = 4;
    const STATUS_PAID      = 5;
    const STATUS_SHIPPED   = 6;

    const STATUS_MAX = 6;

    /**
     * Get an array with all status values
     */
    public function getStatusValues()
    {
        global $_ARRAYLANG;

        $statusValues = array();
        for ($i = 0; $i <= $this::STATUS_MAX; $i++) {
            array_push(
                $statusValues,
                $_ARRAYLANG['TXT_SHOP_ORDER_STATUS_' . $i]
            );
        }

        return $statusValues;
    }

    /**
     * Deletes the Order with the given ID
     *
     * @param   integer   $id           The Order ID
     * @param   boolean   $updateStock  True to update stock of the product
     *
     * @throws \Doctrine\ORM\OptimisticLockException
     */
    public function deleteById($id, $updateStock = false)
    {
        $id = contrexx_input2int($id);
        if (empty($id)) {
            return;
        }

        $order = $this->findOneBy(array('id'=>$id));
        $objUser = \FWUser::getFWUserObject()->objUser;

        if ($order
            && $customer = $objUser->getUser($order->getCustomerId())) {
            $usernamePrefix = \Cx\Modules\Shop\Model\Entity\Orders::USERNAME_PREFIX;

            $customerEmail = $usernamePrefix ."_${$id}_%-"
                . $customer->getEmail();
            $allCustomerWithEmail = $objUser->getUsers(
                array('email' => $customerEmail)
            );

            foreach ($allCustomerWithEmail as $customerWithEmail) {
                $customerWithEmail->setActiveStatus(false);
            }

            $order->setStatus($this::STATUS_DELETED);
            $order->setModifiedBy(contrexx_raw2db($objUser->getUsername()));
            $order->setModifiedOn(new \DateTime('now'));

            if ($updateStock) {
                $this->updateStock($order);
            }

            $this->_em->persist($order);
            $this->_em->flush();
        }

    }

    /**
     * Update related product stock
     *
     * @param boolean $increaseStock True to increase stock, false to decrease
     *
     * @throws \Doctrine\ORM\OptimisticLockException
     */
    protected function updateStock($order, $increaseStock = true)
    {
        global $_ARRAYLANG;

        $items = $order->getOrderItems();

        foreach ($items as $item) {
            $product =  $item->getProduct();

            if (!$product) {
                \DBG::log(sprintf(
                    $_ARRAYLANG['TXT_SHOP_PRODUCT_NOT_FOUND'],
                    $product->getId()
                ));
                continue;
            }

            $stock = $product->getStock();
            if ($increaseStock) {
                $stock += $item->getQuantity();
            } else {
                $stock -= $item->getQuantity();
            }

            $product->setStock($stock);
            $this->_em->persist($product);
        }

        $this->_em->flush();
    }

    public function getFirstOrder()
    {
        $firstOrder = $this->findOneBy(array(), array('dateTime' => 'ASC'));

        return $firstOrder;
    }

    /**
     * Updates the status of the Order with the given ID
     *
     * If the order exists and has the pending status (status == 0),
     * it is updated according to the payment and distribution type.
     * Note that status other than pending are never changed!
     * If the optional argument $newOrderStatus is set and not pending,
     * the order status is set to that value instead.
     * Returns the new Order status on success.
     * If either the order ID is invalid, or if the update fails, returns
     * the Order status "pending" (zero).
     * @access  private
     * @static
     * @param   integer $order_id    The ID of the current order
     * @param   integer $newOrderStatus The optional new order status.
     * @param   string  $handler    The Payment type name in use
     * @return  integer             The new order status (may be zero)
     *                              if the order status can be changed
     *                              accordingly, zero otherwise
     */
    public function update_status($order_id, $newOrderStatus=0, $handler=NULL)
    {
        global $_ARRAYLANG;

        if (is_null($handler) && isset($_REQUEST['handler'])) {
            $handler = contrexx_input2raw($_REQUEST['handler']);
        }
        $order_id = intval($order_id);
        if ($order_id == 0) {
            return self::STATUS_CANCELLED;
        }

        $order = $this->findOneBy(array('id' => $order_id));
        if (empty($order)) {
            return self::STATUS_CANCELLED;
        }
        $status = $order->getStatus();
        // Never change a non-pending status!
        // Whether a payment was successful or not, the status must be
        // left alone.
        if ($status != self::STATUS_PENDING) {
            // The status of the order is not pending.
            // This may be due to a wrong order ID, a page reload,
            // or a PayPal IPN that has been received already.
            // No order status is changed automatically in these cases!
            // Leave it as it is.
            return $status;
        }
        // Determine and verify the payment handler
        $payment_id = $order->getPaymentId();
//if (!$payment_id) DBG::log("update_status($order_id, $newOrderStatus): Failed to find Payment ID for Order ID $order_id");
        $processor_id = \Cx\Modules\Shop\Controller\Payment::getPaymentProcessorId($payment_id);
//if (!$processor_id) DBG::log("update_status($order_id, $newOrderStatus): Failed to find Processor ID for Payment ID $payment_id");
        $processorName = \Cx\Modules\Shop\Controller\PaymentProcessing::getPaymentProcessorName($processor_id);
//if (!$processorName) DBG::log("update_status($order_id, $newOrderStatus): Failed to find Processor Name for Processor ID $processor_id");
        // The payment processor *MUST* match the handler returned.
        if (!preg_match("/^$handler/i", $processorName)) {
//DBG::log("update_status($order_id, $newOrderStatus): Mismatching Handlers: Order $processorName, Request ".$_GET['handler']);
            return self::STATUS_CANCELLED;
        }
        // Only if the optional new order status argument is zero,
        // determine the new status automatically.
        if ($newOrderStatus == self::STATUS_PENDING) {
            // The new order status is determined by two properties:
            // - The method of payment (instant/deferred), and
            // - The method of delivery (if any).
            // If the payment takes place instantly (currently, all
            // external payments processors are considered to do so),
            // and there is no delivery needed (because it's all
            // downloads), the order status is switched to 'completed'
            // right away.
            // If only one of these conditions is met, the status is set to
            // 'paid', or 'delivered' respectively.
            // If neither condition is met, the status is set to 'confirmed'.
            $newOrderStatus = self::STATUS_CONFIRMED;
            $processorType =
                \Cx\Modules\Shop\Controller\PaymentProcessing::getCurrentPaymentProcessorType($processor_id);
            $shipmentId = $order->getShipmentId();
            if ($processorType == 'external') {
                // External payment types are considered instant.
                // See $_SESSION['shop']['isInstantPayment'].
                if ($shipmentId == 0) {
                    // instant, download -> completed
                    $newOrderStatus = self::STATUS_COMPLETED;
                } else {
                    // There is a shipper, so this order will bedelivered.
                    // See $_SESSION['shop']['isDelivery'].
                    // instant, delivery -> paid
                    $newOrderStatus = self::STATUS_PAID;
                }
            } else {
                // Internal payment types are considered deferred.
                if ($shipmentId == 0) {
                    // deferred, download -> shipped
                    $newOrderStatus = self::STATUS_SHIPPED;
                }
                //else { deferred, delivery -> confirmed }
            }
        }
        $order->setStatus($newOrderStatus);
        $this->_em->persist($order);
        $this->_em->flush();

        if (   $newOrderStatus == self::STATUS_CONFIRMED
            || $newOrderStatus == self::STATUS_PAID
            || $newOrderStatus == self::STATUS_SHIPPED
            || $newOrderStatus == self::STATUS_COMPLETED) {
            if (!\Cx\Modules\Shop\Controller\ShopLibrary::sendConfirmationMail($order_id)) {
                // Note that this message is only shown when the page is
                // displayed, which may be on another request!
                \Message::error($_ARRAYLANG['TXT_SHOP_UNABLE_TO_SEND_EMAIL']);
            }
        }
        // The shopping cart *MUST* be flushed right after this method
        // returns a true value (greater than zero).
        // If the new order status is zero however, the cart may
        // be left alone and the payment process can be tried again.
        return $newOrderStatus;
    }
}