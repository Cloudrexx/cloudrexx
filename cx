#!/bin/bash
@GOTO WINDOOF \
2>/dev/null

#!/bin/bash
# vim: syn=sh

COMMANDS=()
declare -A ARGUMENTS
declare -A FORCED_ARGUMENTS
declare -A DEFAULT_CONFIG
declare -A CONFIG
INTERNAL_COMMANDS=("envs" "env" "debug")

#######################
# Input param cleanup #
#######################

# default values
DEFAULT_CONFIG=(
    ["port"]=80
    ["hostname"]=""
    ["php-version"]=""
    ["db-image"]="mariadb:latest"
    ["php-image"]="cloudrexx/web:PHP<phpversion>-with-mysql"
    ["db-pass"]=""
    ["db-user"]=""
    ["db-host"]=""
)
ARGUMENTS=(
    ["port"]=80
    ["php-image"]="cloudrexx/web:PHP<phpversion>-with-mysql"
    ["db-image"]="mariadb:latest"
    ["source-repo"]="git@github.com:Cloudrexx/cloudrexx.git"
    ["source-branch"]="master"
    ["scripts-repo"]="git@github.com:Cloudrexx/scripts.git"
    ["scripts-branch"]="master"
)

# iterate over all arguments to separate commands and arguments
for arg in "$@"
do
    if [[ "$arg" == --* ]]; then
        arg="${arg:2:${#arg}-2}"
        if [[ "$arg" = --*=* ]]; then
            IFS='='; read -r key value <<< "$arg"
            ARGUMENTS[$key]=$value
            FORCED_ARGUMENTS[$key]=$value
        else
            ARGUMENTS[$arg]=true
        fi
    else
        COMMANDS+=("$arg")
    fi
done

##################
# "help" command #
##################
function cmd_help {
    case "$1" in
        envs)
            case "$2" in
                init)
                    # TODO: Add help text
                    ;;
                up)
                    # TODO: Add help text
                    ;;
                down)
                    # TODO: Add help text
                    ;;
                restart)
                    # TODO: Add help text
                    ;;
                status)
                    # TODO: Add help text
                    ;;
                info)
                    # TODO: Add help text
                    ;;
                update)
                    # TODO: Add help text
                    ;;
                *)
                    echo "This command manages the environment for multiple Cloudrexx installations on one host

Synopsis
    ./cx envs <subcommand> [<options>]

Available subcommands are:
    init        Initializes the docker containers (only needs to be called once per host).
    up          Starts the docker containers.
    down        Stops the docker containers.
    restart     Restarts the docker containers.
    status      Tells whether the containers are running.
    info        Alias for 'status'.
    update      Pulls the newest version of the containers.

For more info about a subcommand type ./cx help envs <subcommand>";
                    ;;
            esac
            ;;
        env)
            case "$2" in
                init)
                    echo "This command (re-)initializes a Cloudrexx installation and its environment.

Basically it does the following:
    - Checks out main source repository
    - Checks out helper scripts repository
    - Generates docker configuration (docker-compose.yml)
    - Starts necessary docker containers
    - Loads database

Synopsis
    ./cx env init [<options>]

Available options are:
    --yes                           Answer all questions with yes. Use with care!
    --silent                        Do not output non-necessary messages
    --scale=<int>                   Sets the number of PHP-Containers to spawn. Useful for testing.
    --skip-source                   Skips GIT clone for source code repository
    --source-repo=<repoUrl>         GIT-URL for the source code repository. Default is https://github.com/Cloudrexx/cloudrexx
    --source-branch=<branchName>    GIT branch to check out of the source code repository. Default is master.
    --skip-scripts                  Skips GIT clone for scripts repository
    --scripts-dir=<dir>             Locale directory to use as scripts directory instead of cloning from GIT repository
    --scripts-repo=<repoUrl>        GIT-URL for the scripts repository. Default is https://github.com/Cloudrexx/scripts
    --scripts-branch=<branchName>   GIT branch to check out of the scripts repository. Default is master.

In addition all options of ./cx env config can be used, see ./cx help env config."
                    ;;
                up)
                    echo "This command starts the environment for your installation.

Synopsis
    ./cx env up"
                    ;;
                down)
                    echo "This command stops the environment for your installation.

Synopsis
    ./cx env down"
                    ;;
                restart)
                    echo "This command restarts the environment for your installation.

Synopsis
    ./cx env restart"
                    ;;
                status)
                    echo "This command shows if the environment for your installation is up and running.

Synopsis
    ./cx env status"
                    ;;
                info)
                    echo "This command shows the status and configuration of the environment for your installation.

Synopsis
    ./cx env info"
                    ;;
                update)
                    echo "This command updates your installation.

Synopsis
    ./cx env update [<options>]

Available options are:
    --yes               Answer all questions with yes. Use with care!
    --silent            Do not output non-necessary messages
    --db                If set without setting --git only database is updated
    --git               If set without setting --db only GIT is updated
    --reset             Forces reset of the database even if dump has not changed
    --drop-sessions     Skips restoring user sessions"
                    ;;
                config)
                    echo "This command configures your installation.

Default behavior:
    - If configuration does not yet exist, use default values (or arguments, if set)
    - If configuration exists, only change values in arguments
The option --interactive forces the command to ask for each value

Synopsis
    ./cx env config [<options>]

Available options are:
    --yes                           Answer all questions with yes / default. Use with care!
    --silent                        Do not output non-necessary messages
    --interactive                   Ask for each value instead of using default behavior
    --db-host=<hostname>            Sets database host to <hostname>
    --db-name=<dbname>              Sets database name to <dbname>
    --db-user=<username>            Sets database user to <username>
    --db-pass=<password>            Sets database password to <password>
    --php-image=<dockerImageName>   Name of the docker image to use. Default is 'cloudrexx/web:PHP<php_version>-with-mysql'.
    --db-image=<dockerImageName>    Name of the docker image to use. Default is 'mariadb'.
    --php-version=<phpversion>      Sets PHP version to <phpversion> (example: 7.2), default is based on Cloudrexx version
    --hostname=<hostname>           Sets installation hostname to <hostname>, defaults to parent directory name
    --port=<port>                   Sets installation port to <port>, defaults to 80"
                    ;;
                *)
                    echo "This command manages a Cloudrexx installation and its environment.

Synopsis
    ./cx env <subcommand> [<options>]

Available subcommands are:
    init        (Re-)Initializes the environment:
    up          Starts the necessary docker containers
    down        Stops the necessary docker containers
    restart     Restarts the necessary docker containers
    status      Checks if all necessary docker containers are running
    info        Calls 'status' and prints environment information
    update      Updates docker images and GIT and reloads database
    config      Configures Cloudrexx (config/configuration.php)

For more info about a subcommand type ./cx help env <subcommand>";
                    ;;
            esac
            ;;
        help)
            echo "Shows this help"
            ;;
        debug)
            echo "For now this command simply outputs the last fatal error. More to come..."
            ;;
        *)
            echo "Executes commands for Cloudrexx installations.

Synopsis
    ./cx <command> [<subcommand> [...]] [<cmd_options>] [<cmd_arguments>]

The following commands are available:
    envs        Manages development environments
    env         Manages a development environment
    help        Shows this help
    debug       Returns the last fatal error

All other commands are routed to the installed Cloudrexx installation (if available)

For more infor about a command type ./cx help <command>"
            ;;
    esac
}

##################
# "envs" command #
##################
function cmd_envs {
    case "$1" in
        init)
            # TODO: Add code
            ;;
        up)
            # TODO: Add code
            ;;
        down)
            # TODO: Add code
            ;;
        restart)
            # TODO: Add code
            ;;
        status)
            # TODO: Add code
            ;;
        info)
            # TODO: Add code
            ;;
        update)
            # TODO: Add code
            ;;
        *)
            (>&2 echo "No such subcommand")
            ;;
    esac
}

#################
# "env" command #
#################
function cmd_env {
    case "$1" in
        init)
            if [[ ${ARGUMENTS["yes"]} != true ]]; then
                echo "This will install Cloudrexx in the current directory ($(pwd))"
                read -p "Continue [Yn]? " -n 1 -r
                if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
                    return
                fi
            fi
            if [[ ${ARGUMENTS["silent"]} != true ]]; then
                echo "Checking out source and scripts repo"
            fi
            if [[ ${ARGUMENTS["skip-source"]} != true ]]; then
                git clone ${ARGUMENTS["source-repo"]} --branch=${ARGUMENTS["source-branch"]} .
            fi
            if [[ ${ARGUMENTS["skip-scripts"]} != true ]]; then
                if [[ ${ARGUMENTS["scripts-dir"]} != "" ]]; then
                    ln -s ${ARGUMENTS["scripts-dir"]} "_meta"
                else
                    git clone ${ARGUMENTS["scripts-repo"]} --branch=${ARGUMENTS["scripts-branch"]} _meta
                fi
            fi
            if [[ ${ARGUMENTS["silent"]} != true ]]; then
                echo "Configuring the environment"
            fi
            if [[ ${ARGUMENTS["yes"]} = false ]]; then
                ARGUMENTS["interactive"]=true
            fi
            cmd_env config
            if [[ ${ARGUMENTS["silent"]} != true ]]; then
                echo "Loading docker containers"
            fi
            cmd_env up
            if [[ ${ARGUMENTS["silent"]} != true ]]; then
                echo "Loading database"
            fi
            ARGUMENTS["db"]=true && cmd_env update
            if [[ ${ARGUMENTS["silent"]} != true ]]; then
                echo "Environment successfully initialized, you should be able to reach Cloudrexx at http://${ARGUMENTS["hostname"]}.lvh.me/"
            fi
            ;;
        up)
            dockercomposeexec up
            ;;
        down)
            dockercomposeexec down
            ;;
        restart)
            dockercomposeexec restart
            ;;
        status)
            dockercomposeexec ps
            ;;
        info)
            cmd_env status
            ARGUMENTS["show"]=true && cmd_env config
            ;;
        update)
            # TODO: Update docker containers
            STRUCTMD5=$(/usr/bin/md5sum installer/data/contrexx_dump_structure.sql)
            DATAMD5=$(/usr/bin/md5sum installer/data/contrexx_dump_data.sql)
            get_config_array
            if [[ ${ARGUMENTS["db"]} != true || ${ARGUMENTS["git"]} = true ]]; then
                if [[ ${ARGUMENTS["reset"]} == true ]]; then
                    if [[ ${ARGUMENTS["yes"]} != true ]]; then
                        echo "This will remove all local changes. Are you sure?"
                        read -p "Continue [Ny]? " -n 1 -r
                        if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
                            return
                        fi
                    fi
                    git fetch
                    git reset --hard
                    git clean -ffdx
                    set_config_array
                else
                    git stash
                    git pull
                    git stash pop
                fi
            fi
            STRUCTMD5NEW=$(/usr/bin/md5sum installer/data/contrexx_dump_structure.sql)
            DATAMD5NEW=$(/usr/bin/md5sum installer/data/contrexx_dump_data.sql)
            if [[ "$STRUCTMD5NEW" != "$STRUCTMD5" || "$DATAMD5NEW" != "$DATAMD5" ]]; then
                DB_UPDATE_NECESSARY=true
            else
                DB_UPDATE_NECESSARY=false
            fi
            if [[ ${ARGUMENTS["git"]} != true || ${ARGUMENTS["db"]} = true ]]; then
                if [[ ${ARGUMENTS["reset"]} = false && $DB_UPDATE_NECESSARY = false && ${ARGUMENTS["silent"]} = false ]]; then
                    echo "DB update not necessary, run ./cx env update --db --reset to force db reload"
                    return
                fi
                DB_CONF=$(mktemp)
                echo "[client]
host=${CONFIG["db-host"]}
database=${CONFIG["db-name"]}
user=${CONFIG["db-user"]}
password=${CONFIG["db-pass"]}" > "$DB_CONF"
# TODO: dump no longer contains users, handle them as we do sessions
                if [[ ${ARGUMENTS["drop-sessions"]} = false ]]; then
                    DB_SESSION_FILE="$(mktemp)"
                    mysqldump --defaults-file="$DB_CONF" contrexx_sessions > "$DB_SESSION_FILE"
                fi
                # empty database if exists
# from https://stackoverflow.com/questions/12403662/how-to-remove-all-mysql-tables-from-the-command-line-without-drop-database-permi
                mysql --defaults-file="$DB_CONF" -A -e "
SET FOREIGN_KEY_CHECKS = 0;
SET GROUP_CONCAT_MAX_LEN=32768;
SET @tables = NULL;
SELECT GROUP_CONCAT('\`', table_name, '\`') INTO @tables
      FROM information_schema.tables
        WHERE table_schema = (SELECT DATABASE());
SELECT IFNULL(@tables,'dummy') INTO @tables;

SET @tables = CONCAT('DROP TABLE IF EXISTS ', @tables);
PREPARE stmt FROM @tables;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
SET @views = NULL;
SELECT GROUP_CONCAT('\`', TABLE_NAME, '\`') INTO @views
      FROM information_schema.views
        WHERE table_schema = (SELECT DATABASE());
SELECT IFNULL(@views,'dummy') INTO @views;

SET @views = CONCAT('DROP VIEW IF EXISTS ', @views);
PREPARE stmt FROM @views;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
SET FOREIGN_KEY_CHECKS = 1;"
                # create db if it does not exist
                mysql --defaults-file="$DB_CONF" -A -e "CREATE DATABASE IF NOT EXISTS ${CONFIG["db-name"]} COLLATE utf8_unicode_ci"
                # load db
                mysql --defaults-file="$DB_CONF" -A < installer/data/contrexx_dump_structure.sql
                mysql --defaults-file="$DB_CONF" -A < installer/data/contrexx_dump_data.sql
                if [[ ${ARGUMENTS["drop-sessions"]} = false ]]; then
                    mysql --defaults-file="$DB_CONF" -A < "$DB_SESSION_FILE"
                    rm -f "$DB_SESSION_FILE"
                fi
                rm -f "$DB_CONF"
            else
                if [[ $DB_UPDATE_NECESSARY = true && ${ARGUMENTS["silent"]} = false ]]; then
                    echo "DB update would be necessary, you may want to run ./cx env update --db"
                fi
            fi
            ;;
        config)
            if [[ ${ARGUMENTS["show"]} = true ]]; then
                echo -e "Key\t\tValue"
                echo "========================"
                get_config_array
                for value in "${!CONFIG[@]}"; do
                    echo -e "$value\t\t${CONFIG[$value]}"
                done
                return
            fi
            get_config_array
            if [ ${#CONFIG[@]} -eq 0 ]; then
                # load config, if its empty: load default config over it
                for value in "${!ARGUMENTS[@]}"; do
                    CONFIG_OVERRIDE[$value]=${ARGUMENTS[$value]}
                done
            else
                # else only load forced arguments over it
                for value in "${!FORCED_ARGUMENTS[@]}"; do
                    CONFIG_OVERRIDE[$value]=${FORCED_ARGUMENTS[$value]}
                done
            fi
            # loop over CONFIG_OVERRIDE and override all 
            for value in "${!CONFIG_OVERRIDE[@]}"; do
                CONFIG[$value]=${CONFIG_OVERRIDE[$value]}
            done
            # if interactive: loop over all options and let the user decide
            if [[ ${ARGUMENTS["interactive"]} = true ]]; then
                # TODO: Only ask if argument is not in forced arguments
                for value in "${!DEFAULT_CONFIG[@]}"; do
                    read -p "Enter value for '$value' [${CONFIG[$value]}]: " newvalue
                    if [[ "$newvalue" != "" ]]; then
                        CONFIG[$value]=$newvalue
                    fi
                done
            fi
            set_config_array
            ;;
        *)
            (>&2 echo "No such subcommand")
            ;;
    esac
}

function get_config_array {
    CONFIG_FILE="config/configuration.php"
    SETTINGS_FILE="config/settings.php"
    COMPOSE_FILE="docker-compose.yml"
    if ! [[ -f $CONFIG_FILE ]] || ! [[ -f $SETTINGS_FILE ]] || ! [[ -f $COMPOSE_FILE ]]; then
        CONFIG=()
        return
    fi
    # TODO: Add code for db-image, php-image and php-version magic
    CONFIG=(
        ["db-host"]=$(REGEX="DBCONFIG\['host'\]\ +=\ +(['\"])([^'\"]+)\1;"; CFG=$(cat $CONFIG_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[2]}")
        ["db-name"]=$(REGEX="DBCONFIG\['database'\]\ +=\ +(['\"])([^'\"]+)\1;"; CFG=$(cat $CONFIG_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[2]}")
        ["db-user"]=$(REGEX="DBCONFIG\['user'\]\ +=\ +(['\"])([^'\"]+)\1;"; CFG=$(cat $CONFIG_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[2]}")
        ["db-pass"]=$(REGEX="DBCONFIG\['password'\]\ +=\ +(['\"])([^'\"]+)\1;"; CFG=$(cat $CONFIG_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[2]}")
        ["hostname"]=$(REGEX="CONFIG\['domainUrl'\]\ +=\ +(['\"])([^'\"]+)\1;"; CFG=$(cat $SETTINGS_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[2]}")
        ["port"]=$(REGEX="CONFIG\['portFrontendHTTP'\]\ +=\ +([0-9]+);"; CFG=$(cat $SETTINGS_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[1]}")
        ["php-version"]="Not yet available"
        ["php-image"]="Not yet available"
        ["db-image"]="Not yet available"
    )
}

function set_config_array {
    # load config file
    FILE_CONTENTS=$(cat config/configuration.php)
    # replace db-host, db-name, db-user, db-pass
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((DBCONFIG\['host'\]\ +=\ +['\"])[^'\"]+(['\"];))" "${CONFIG["db-host"]}")
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((DBCONFIG\['database'\]\ +=\ +['\"])[^'\"]+(['\"];))" "${CONFIG["db-name"]}")
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((DBCONFIG\['user'\]\ +=\ +['\"])[^'\"]+(['\"];))" "${CONFIG["db-user"]}")
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((DBCONFIG\['password'\]\ +=\ +['\"])[^'\"]+(['\"];))" "${CONFIG["db-pass"]}")
    # save config file
    echo "$FILE_CONTENTS" > config/configuration.php

    # load settings
    FILE_CONTENTS=$(cat config/settings.php)
    # replace hostname, port
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((CONFIG\['port'\]\ +=\ +)[0-9]+(;))" "${CONFIG["port"]}")
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((CONFIG\['domainUrl'\]\ +=\ +['\"])[^'\"]+(['\"];))" "${CONFIG["hostname"]}")
    # save settings
    echo "$FILE_CONTENTS" > config/settings.php

    # load _meta/docker-compose.yml
    FILE_CONTENTS=$(cat _meta/docker-compose.yml)
    # replace php-image with php-version internally
    PHP_IMAGE=${CONFIG["php-image"]}
    PHP_IMAGE=${PHP_IMAGE//"<version>"/${CONFIG["php-version"]}}
    # replace hostname, php- and db-image
    FILE_CONTENTS=${FILE_CONTENTS//"<hostname>"/${CONFIG["hostname"]}}
    FILE_CONTENTS=${FILE_CONTENTS//"<php-image>"/$PHP_IMAGE}
    FILE_CONTENTS=${FILE_CONTENTS//"<db-image>"/${CONFIG["db-image"]}}
    # save docker-compose.yml
    echo "$FILE_CONTENTS" > docker-compose.yml
}

# regex_replace <haystack> <regex> <replacement>
# regex match 1 needs to be whole match
# regex match 2 needs to be everything before replaced part
# regex match 3 needs to be everything after replaced part
function regex_replace {
    local HAYSTACK="$1"
    local REGEX="$2"
    local REPLACEMENT="$3"
    [[ "$HAYSTACK" =~ $REGEX ]]
    REPLACE="${BASH_REMATCH[2]}${REPLACEMENT}${BASH_REMATCH[3]}"
    HAYSTACK="${HAYSTACK//"${BASH_REMATCH[0]}"/"$REPLACE"}"
    echo "$HAYSTACK"
}

#####################
# Wrapper functions #
#####################
function phpexec {
    # TODO: Check if we should run async
    dockerexec exec php-master php index.php $@
}

function dockerexec {
    # TODO: Check if --no-docker is set
    docker $@
}

function dockercomposeexec {
    # TODO: Check if --no-docker is set
    docker-compose $@
}

#####################
# Decide what to do #
#####################

case "${COMMANDS[0]}" in
    envs)
        COMMANDS=("${COMMANDS[@]:1}")
        cmd_envs "${COMMANDS[@]/#/}"
        ;;
    env)
        COMMANDS=("${COMMANDS[@]:1}")
        cmd_env "${COMMANDS[@]/#/}"
        ;;
    debug)
        tac tmp/log/dbg.log | grep -m1 "initialization failed"
        ;;
    help)
        # wrapper for "help" command to deliver help for internal commands
        if [[ " ${INTERNAL_COMMANDS[*]} " = " ${COMMANDS[1]} " ]]; then
            COMMANDS=("${COMMANDS[@]:1}")
            cmd_help "${COMMANDS[@]/#/}"
        else
            phpexec help "${COMMANDS[1]}"
        fi
        ;;
    *)
        # if system looks installed
        if [ -f "index.php" ]; then
            # TODO: add help text if return value indicates a setup problem (db conn., .htaccess, ...)
            phpexec $@
        else
            echo "Cloudrexx does not seem to be installed. Did you already execute the \"env init\" command?"
            cmd_help "${COMMANDS[1]}"
        fi
        ;;
esac

#########################################
# End of nice part, lesser systems next #
#########################################

exit
:WINDOOF
@ECHO off

REM Make sure our wrapper-container is running
docker run --rm -dti --name ubuntu -v %cd%/:/root ubuntu

REM Route all calls to our linux environment
REM TODO: Pass all params
REM TODO: The linux environment should not start sub-containers but containers on the host-system
docker exec -ti ubuntu bash -c "./clx.bat --no-docker"
REM TODO: Handle return value in case its a docker command
